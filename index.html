<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UYEN XINH</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #preview-video {
            position: absolute; bottom: 10px; right: 10px;
            width: 160px; height: 120px; border-radius: 8px;
            transform: scaleX(-1); border: 1px solid #444; z-index: 10;
        }
    </style>
</head>
<body>
    <video id="input-video" style="display:none"></video>
    <canvas id="preview-video"></canvas>

    <script>
        const PARTICLE_COUNT = 20000;
        let expansionFactor = 0, currentShape = 'heart', time = 0;
        let targetPos = { x: 0, y: 0 }, currentPos = { x: 0, y: 0 }, sE = 0;
        let transitionParticles = []; 
        const shapePresets = { heart: [], planet: [], iloveyou: [], uynnxinh: [] };
        let targets = [], dirs = [];

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 22; 
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({ size: 0.045, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.9 });
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        function initShapes() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = i / PARTICLE_COUNT;
                const b = (Math.random() - 0.5) * 0.3;
                const z = (Math.random() - 0.5) * 0.5;

                // 1. HEART
                const tH = Math.random() * Math.PI * 2;
                shapePresets.heart.push(new THREE.Vector3(0.25*(16*Math.pow(Math.sin(tH),3)), 0.25*(13*Math.cos(tH)-5*Math.cos(2*tH)-2*Math.cos(3*tH)-Math.cos(4*tH)), z*2));

                // 2. PLANET
                if (i < PARTICLE_COUNT * 0.6) {
                    const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.6)), theta = Math.sqrt(PARTICLE_COUNT * 0.6 * Math.PI) * phi;
                    shapePresets.planet.push(new THREE.Vector3(5*Math.cos(theta)*Math.sin(phi), 5*Math.sin(theta)*Math.sin(phi), 5*Math.cos(phi)));
                } else {
                    const a = Math.random()*Math.PI*2, r = 7 + Math.random()*3;
                    shapePresets.planet.push(new THREE.Vector3(Math.cos(a)*r, (Math.random()-0.5)*0.5, Math.sin(a)*r));
                }

                // 3. I LOVE YOU
                let lx = 0, ly = 0;
                const ls = 0.45;
                if (p < 0.05) { lx = -40; ly = (Math.random()-0.5)*14; } 
                else if (p < 0.15) { if (Math.random()>0.3) { lx = -22; ly = (Math.random()-0.5)*14; } else { lx = -22 + Math.random()*8; ly = -7; } }
                else if (p < 0.30) { const ang = Math.random()*Math.PI*2; lx = -5 + Math.cos(ang)*5; ly = Math.sin(ang)*7; }
                else if (p < 0.45) { const tV = (Math.random()-0.5)*2; lx = 12 + tV*5; ly = Math.abs(tV)*14 - 7; }
                else if (p < 0.60) { const rE = Math.random(); lx = 23 + Math.random()*8; if (rE<0.4) { lx = 23; ly = (Math.random()-0.5)*14; } else if (rE<0.6) ly = 7; else if (rE<0.8) ly = 0; else ly = -7; }
                else if (p < 0.70) { const tY = (Math.random()-0.5)*2; if (tY < 0) { lx = 45 + tY*4; ly = -tY*7; } else { lx = 45 + tY*4; ly = tY*7; } if (Math.random()>0.6) { lx = 45; ly = -Math.random()*7; } }
                else if (p < 0.85) { const ang = Math.random()*Math.PI*2; lx = 58 + Math.cos(ang)*5; ly = Math.sin(ang)*7; }
                else { const tU = Math.random()*Math.PI; lx = 71 + Math.cos(tU+Math.PI)*5; ly = (Math.sin(tU+Math.PI)*8) + 2; if (Math.random()>0.4) { lx = (Math.random()>0.5?66:76); ly = 2+Math.random()*5; } }
                shapePresets.iloveyou.push(new THREE.Vector3((lx - 15)*ls, ly*ls, z));

                // 4. UYEN XINH (THU NHỎ 1/2)
                let ux = 0, uy = 0;
                const us = 0.28; // Giảm hệ số này để thu nhỏ chữ
                if (p < 0.12) { // U
                    const tU = Math.random()*Math.PI; ux = -15 + Math.cos(tU+Math.PI)*4.5; uy = Math.sin(tU+Math.PI)*7 + 2;
                    if (Math.random()>0.5) { ux = (Math.random()>0.5?-19.5:-10.5); uy = 2+Math.random()*5; }
                } else if (p < 0.22) { // Y
                    const tY = (Math.random()-0.5)*2;
                    if (tY < 0) { ux = -2 + tY*4.5; uy = -tY*8; } else { ux = -2 + tY*4.5; uy = tY*8; }
                    if (Math.random()>0.6) { ux = -2; uy = -Math.random()*8; }
                } else if (p < 0.34) { // E (Đổi từ N sang E)
                    const rE = Math.random(); ux = 10 + Math.random()*7;
                    if (rE<0.4) { ux = 10; uy = (Math.random()-0.5)*14; } else if (rE<0.6) uy = 7; else if (rE<0.8) uy = 0; else uy = -7;
                } else if (p < 0.46) { // N
                    ux = 22 + (Math.random()>0.5?0:7); uy = (Math.random()-0.5)*14;
                    if (Math.random()>0.7) { const tN = Math.random(); ux = 22 + tN*7; uy = 7 - tN*14; }
                } 
                else if (p < 0.60) { // X
                    const tX = (Math.random()-0.5)*2; ux = 48 + tX*5; uy = (Math.random()>0.5? tX*8 : -tX*8);
                } else if (p < 0.72) { // I
                    ux = 57; uy = (Math.random()-0.5)*14;
                } else if (p < 0.86) { // N
                    ux = 63 + (Math.random()>0.5?0:7); uy = (Math.random()-0.5)*14;
                    if (Math.random()>0.7) { const tN = Math.random(); ux = 63 + tN*7; uy = 7 - tN*14; }
                } else { // H
                    ux = 74 + (Math.random()>0.5?0:7); uy = (Math.random()-0.5)*14;
                    if (Math.random()>0.7) { ux = 74 + Math.random()*7; uy = 0; }
                }
                shapePresets.uynnxinh.push(new THREE.Vector3((ux - 30)*us + b, uy*us + b, z));

                transitionParticles.push(shapePresets.heart[i].clone());
            }
            targets = shapePresets['heart'];
            dirs = targets.map(t => t.clone().normalize().multiplyScalar(Math.random() * 20 + 10));
        }

        function switchShape(name) {
            if (currentShape === name) return;
            currentShape = name;
            targets = shapePresets[name];
            dirs = targets.map(t => t.clone().normalize().multiplyScalar(Math.random() * 20 + 10));
            // ĐỔI SANG MÀU XANH NEON (0x00ffff) CHO UYEN XINH
            material.color.set(name === 'heart' ? 0xff3366 : (name === 'planet' ? 0x00ffff : (name === 'uynnxinh' ? 0x00ffff : 0xff0088)));
        }

        initShapes();

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        
        hands.onResults((res) => {
            const cv = document.getElementById('preview-video');
            const ctx = cv.getContext('2d');
            cv.width = 640; cv.height = 480;
            ctx.save(); ctx.clearRect(0,0,640,480); ctx.drawImage(res.image,0,0,640,480); ctx.restore();

            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                targetPos.x = -(lm[9].x - 0.5) * 35;
                targetPos.y = -(lm[9].y - 0.5) * 26;

                const open = (i) => lm[i].y < lm[i-2].y;
                const distOK = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                const isOK = distOK < 0.05;

                const allOpen = Math.abs(lm[4].x - lm[9].x) > 0.12 && open(8) && open(12) && open(16) && open(20);
                expansionFactor = allOpen ? 1.4 : 0;

                if (isOK) switchShape('uynnxinh');
                else if (open(8) && open(12) && !open(16)) switchShape('iloveyou');
                else if (open(8) && !open(12)) switchShape('heart');
                else if (open(8) && open(12) && open(16)) switchShape('planet');
            } else { targetPos = {x:0, y:0}; expansionFactor = 0; }
        });

        const cam = new Camera(document.getElementById('input-video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input-video')}); },
            width: 640, height: 480
        });
        cam.start();

        function animate() {
            requestAnimationFrame(animate);
            time = Date.now() * 0.0012; 
            sE += (expansionFactor - sE) * 0.25;
            currentPos.x += (targetPos.x - currentPos.x) * 0.45;
            currentPos.y += (targetPos.y - currentPos.y) * 0.45;

            const pitch = Math.sin(time * 1.5) * 0.18; 
            particleSystem.position.set(currentPos.x, currentPos.y, 0);
            particleSystem.rotation.set(pitch, Math.cos(time*0.5)*0.1, 0);

            const posArr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                transitionParticles[i].x += (targets[i].x - transitionParticles[i].x) * 0.15;
                transitionParticles[i].y += (targets[i].y - transitionParticles[i].y) * 0.15;
                transitionParticles[i].z += (targets[i].z - transitionParticles[i].z) * 0.15;

                const noise = Math.sin(time * 4 + i) * 0.015;
                posArr[i*3] = transitionParticles[i].x + dirs[i].x * sE + noise;
                posArr[i*3+1] = transitionParticles[i].y + dirs[i].y * sE + noise;
                posArr[i*3+2] = transitionParticles[i].z + dirs[i].z * sE;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>
